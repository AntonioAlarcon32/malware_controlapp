import sys
import socketio
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QLabel, QTextEdit
from PyQt5.QtCore import QEvent

class CounterApp(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()
        self.initSocketIO()

    def initUI(self):
        self.layout = QVBoxLayout(self)
        self.counterLabel = QLabel("Waiting for updates...", self)
        self.layout.addWidget(self.counterLabel)

        self.ipListTextEdit = QTextEdit(self)
        self.ipListTextEdit.setReadOnly(True)
        self.layout.addWidget(self.ipListTextEdit)

    def initSocketIO(self):
        self.sio = socketio.Client()
        self.sio.on('connect', self.on_connect)
        self.sio.on('disconnect', self.on_disconnect)
        self.sio.on('counter_update', self.on_counter_update)
        self.sio.connect('http://127.0.0.1:3000')

    def on_connect(self):
        print("Connected to Socket.IO server")
        self.sio.emit('request_update')

    def on_disconnect(self):
        print("Disconnected from Socket.IO server")

    def on_counter_update(self, data):
        # Update UI from the main thread
        QApplication.instance().postEvent(self, CustomEvent(data))

    def customEvent(self, event):
        # Process the custom event
        data = event.data
        self.counterLabel.setText(f"Endpoint1: {data['endpoint1_count']}, Endpoint2: {data['endpoint2_count']}")
        self.updateIPList(data['ip_counts'])

    def updateIPList(self, ip_counts):
        ipListText = "IP Addresses:\n"
        for ip, counts in ip_counts.items():
            ipListText += f"{ip}: Endpoint1: {counts['endpoint1']}, Endpoint2: {counts['endpoint2']}\n"
        self.ipListTextEdit.setText(ipListText)

class CustomEvent(QEvent):
    def __init__(self, data):
        super().__init__(QEvent.User)
        self.data = data

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = CounterApp()
    ex.show()
    sys.exit(app.exec_())
